/**
 * @param {number} n
 * @return {number[]}
 */


/**
 * 首先要知道所谓的点数概率是怎么求出来的:假设n个骰子扔出后共有sum种可能，其中有M种可能使得骰子总数和为K，则 pro(K)=M/sum
 * 
 * 
 * s 的范围:[1*n,6*n],总共 6n-n+1=5n+1 种可能
 * 
 * 令dp[n][s]表示n个骰子扔出和为s的事件出现的可能情况。
 * 
 * dp[1][1]=1,dp[1][2]=1,dp[1][3]=1,dp[1][4]=1,dp[1][5]=1,dp[1][6]=1
 * dp[2][2]=1,dp[2][3]=2(1->2;2->1),dp[2][4]=3(1->3;2->2;3->1),...dp[2][12]
 * dp[3][3]=1,dp[3][4]=3(1->1->2;1->2->1;2->1->1),
 * 
 * 以 dp[3][4],它由以下情况进一步构成
 * 前面两个骰子分别为1和1,第三个骰子扔出了2
 * 前面两个骰子分别为1和2,第三个骰子扔出了1
 * 前面两个骰子分别为2和1,第三个骰子扔出了1
 * 即 dp[2][2]+dp[2][3]，由于 2,3皆小于4（准确来说差值在1到6之间，即最后一个骰子可能扔出的点数），对于之前已有的情况，第三个骰子一定能扔出对应点数保证凑成4
 */
var dicesProbability = function(n) {

    let dp=Array.from({length:n+1},()=>Array.from({length:6*n+1},()=>0))
    for(let i=1;i<=6;i++){
        dp[1][i]=1
    }

    for(let i=2;i<=n;i++){
        dp[i][i]=1
        for(let j=i+1;j<=6*i;j++){
            dp[i][j]=0
            for(let k=1;k<=6;k++){
                if(j-k>0)
                    dp[i][j]+=dp[i-1][j-k]
            }
        }
    }

    // 最后根据dp[n][n->6n]求各自点数概率
    let sum=0
    for(let i=n;i<=6*n;i++){
        sum+=dp[n][i]
    }
    let res=[]
    for(let i=n;i<=6*n;i++){
        res.push(dp[n][i]/sum)
    }
    return res
};
