/**
 * @param {number[]} A
 * @param {number[]} B
 * @return {number}
 */
var minSwap = function(A, B) {

    // 假设给定的输入总是有效的->满足最优子结构
    // 假设有两种情况 1) A[i]>A[i-1]&&B[i]>B[i-1] 2) A[i]>B[i-1]&&B[i]>A[i-1]
    // 数组A,B的第i位，A[i-1],A[i];B[i-1],B[i] 一定是以下情况之一 
    // 1)满足2)满足: [7,777],[9,999], 第i位可以交换,i-1可以交换也可以不交换;第i位可以不交换,i-1可以交换也可以不交换
    // 1)满足2)不满足: [7,9],[4,5],第i位可以不交换,此时i-1位不能交换;第i位可以交换，此时i-1也必须交换
    // 1)不满足 2)满足：[9,7],[5,12],第i位可以不交换,此时i-1必须交换;第i位可以交换,此时i-1位不能交换

    // 当前位不交换是不是一定比当前位交换要好?
    // 比如[2,9,4,6,8]与[1,3,10,11,12] 第1位的9,3 不交换的话，要想保证两个数组递增，就必须连续交换剩下来的3位。所以不一定当前位不交换一定比当前位交换要好

    // 用 cost[0] 表示当前位不交换时的最小交换次数 用 cost[1] 表示当前位交换时的最小交换次数
    // 我们并没有单独考虑第0位的交换与否，第0位的交换情况要放到第1位的交换与否里,作为上一位去考虑
    let cost=[0,1]
    const {length}=A
    for(let i=1;i<length;i++){
        // 满足 1)
        if(A[i]>A[i-1]&&B[i]>B[i-1]){
            if(A[i]>B[i-1]&&B[i]>A[i-1]){
                // 第 i 位可以交换，也可以不交换，取这两种情况最小值
                cost[0]=Math.min(cost[0],cost[1])
                cost[1]=Math.min(cost[0],cost[1])+1
            }else{
                cost[1]+=1
            }
        }else{
            let temp=cost[0]
            cost[0]=cost[1]
            cost[1]=temp+1

        }
    }
    return Math.min(cost[0],cost[1])
};
